<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>BLE GATT → Google Sheets (Sylvac c/ Auto-Reconnect)</title>
<style>
  :root { color-scheme: light dark; }
  body { font-family: Arial, sans-serif; padding:16px; line-height:1.45; }
  h1 { margin:0 0 10px; font-size:20px; }
  label { display:block; margin-top:10px; font-weight:600; }
  input[type="text"] { width:100%; padding:10px; border:1px solid #ccc; border-radius:8px; font-size:14px; }
  .row { display:grid; grid-template-columns:1fr; gap:10px; }
  @media (min-width:720px){ .row{ grid-template-columns:1fr 1fr; } }
  button { padding:10px 14px; font-size:15px; border-radius:10px; border:0; cursor:pointer; margin-right:8px; margin-top:8px; }
  #btnConnect { background:#0a7; color:#fff; }
  #btnDisconnect { background:#c33; color:#fff; }
  .sec { margin-top:14px; }
  .log { white-space:pre-wrap; background:#f8f8f8; padding:12px; border:1px solid #ddd; border-radius:10px; margin-top:14px; max-height:55vh; overflow:auto; }
  .ok{color:#0a8;} .warn{color:#c80;} .err{color:#c00;} .muted{color:#666;font-size:12px;}
</style>
</head>
<body>
<h1>BLE GATT → Google Sheets (MVP)</h1>
<p class="muted">Sylvac via Web Bluetooth (Android/Chrome). Após conectar, use um dos botões de comando ou o botão do instrumento.</p>

<div class="row">
  <div>
    <label>GAS_ENDPOINT (Apps Script)</label>
    <input type="text" id="endpoint"
      value="https://script.google.com/macros/s/AKfycbwn8jFg3x0CWlLqTOVhT7LJ2XTNdL0d9VEllL8qN3W-RFIFFMZaaxRc3MJiGm01Fxha/exec">
  </div>
  <div>
    <label>Service UUID (Sylvac – medição)</label>
    <input type="text" id="svc" value="c1b25000-caaf-6d0e-4c33-7dae30052840">
  </div>
  <div>
    <label><input type="checkbox" id="battery" checked> Ler nível de bateria (0x180F/0x2A19)</label>
    <div class="muted">Dica: mantenha o instrumento “acordado” (aperte o botão) antes de conectar.</div>
  </div>
  <div>
    <label><input type="checkbox" id="keepalive" checked> Manter conexão ativa (keep-alive a cada 3s)</label>
    <label><input type="checkbox" id="autorec" checked> Auto-reconectar ao desconectar</label>
  </div>
</div>

<div class="sec">
  <button id="btnConnect">Conectar & Assinar</button>
  <button id="btnDisconnect">Desconectar</button>
  <button id="btnReq01">Pedir leitura (0x01)</button>
  <button id="btnReqR">Pedir leitura ("r")</button>
  <button id="btnStart">Start contínuo (0x02)</button>
  <button id="btnStop">Stop (0x03)</button>
</div>

<div class="log" id="log"></div>

<script>
let g = {
  device:null, server:null, svc:null,
  cNotify:null, cIndicate:null, cWrite:null,
  battery:'', deviceLabel:'',
  keepTimer:null, reconnecting:false
};

const logEl = document.getElementById('log');
function log(msg, cls=''){ const d=document.createElement('div'); d.textContent=msg; if(cls) d.className=cls; logEl.appendChild(d); logEl.scrollTop=logEl.scrollHeight; }
function toHex(u8){ return Array.from(u8).map(b=>b.toString(16).padStart(2,'0')).join(' '); }

// === Parser Sylvac: "+014.736 >" → value=14.736, unit=mm, status=NG ===
function decodeSylvac(dv){
  const u8=new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
  const printable = u8.filter(b => b>=0x20 && b<=0x7E);
  const txt = new TextDecoder('utf-8').decode(printable).trim();

  let value = NaN, unit='mm', status='OK';
  const m = txt.match(/[-+]?\d+(?:[.,]\d+)?/);
  if (m) value = parseFloat(m[0].replace(',', '.'));
  if (txt.includes('<') || txt.includes('>')) status='NG';

  return { value, unit, status, rawText: txt };
}

async function postToSheets(endpoint, payload){
  try{
    await fetch(endpoint,{ method:'POST', mode:'no-cors', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload) });
  }catch(e){ log('Falha ao enviar ao GAS: '+e,'warn'); }
}

function onValue(ev){
  const dv=ev.target.value;
  const parsed=decodeSylvac(dv);
  const rawHex=toHex(new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength));

  log('Texto: "'+parsed.rawText+'"', 'muted');

  const payload={
    deviceName: g.deviceLabel || (g.device?.name||''),
    deviceId: g.device?.id || '',
    value: parsed.value,
    unit: parsed.unit,
    status: parsed.status,
    battery: g.battery,
    rawHex
  };
  log('Leitura: '+JSON.stringify(payload),'ok');

  const endpoint=document.getElementById('endpoint').value.trim();
  if(endpoint) postToSheets(endpoint,payload);
}

async function readDISLabel(){
  g.deviceLabel = g.device?.name || '';
  try{
    const dis = await g.server.getPrimaryService('device_information');
    async function readStr(uuid){
      try{
        const c = await dis.getCharacteristic(uuid);
        const v = await c.readValue();
        return new TextDecoder('utf-8').decode(new Uint8Array(v.buffer, v.byteOffset, v.byteLength)).trim();
      }catch{ return ''; }
    }
    const serial = await readStr('serial_number_string');
    const model  = await readStr('model_number_string');
    const fw     = await readStr('firmware_revision_string');
    const mfg    = await readStr('manufacturer_name_string');

    g.deviceLabel = serial || model || g.deviceLabel;
    log(`DIS: serial=${serial||'-'} model=${model||'-'} fw=${fw||'-'} mfg=${mfg||'-'}`, 'muted');
  }catch{
    log('Device Information Service não disponível (seguindo).','warn');
  }
}

function startKeepAlive(){
  clearInterval(g.keepTimer);
  if (!document.getElementById('keepalive').checked) return;
  g.keepTimer = setInterval(async () => {
    try{
      if (g?.server?.connected) {
        if (g.cWrite) {
          // pedido leve de leitura
          await g.cWrite.writeValueWithoutResponse(Uint8Array.from([0x01]));
        } else if (g.battery !== '') {
          // alternativa: reler bateria ocasionalmente
          const bs=await g.server.getPrimaryService('battery_service');
          const bc=await bs.getCharacteristic('battery_level');
          await bc.readValue();
        }
      }
    }catch(_){} // silencioso
  }, 3000);
}

async function setupServiceAndChars(SVC){
  g.svc = await g.server.getPrimaryService(SVC);
  const chars = await g.svc.getCharacteristics();
  g.cNotify = null; g.cIndicate = null; g.cWrite = null;

  for (const c of chars) {
    const p = c.properties || {};
    if (!g.cNotify   && p.notify)                 g.cNotify = c;
    if (!g.cIndicate && p.indicate)               g.cIndicate = c;
    if (!g.cWrite    && (p.writeWithoutResponse || p.write)) g.cWrite = c;
  }

  if (g.cNotify) {
    await g.cNotify.startNotifications();
    g.cNotify.addEventListener('characteristicvaluechanged', onValue);
    log('NOTIFY assinada ('+g.cNotify.uuid+'). Gere uma medida…','ok');
  } else {
    log('Characteristic NOTIFY não encontrada.','warn');
  }

  if (g.cIndicate) {
    await g.cIndicate.startNotifications();
    g.cIndicate.addEventListener('characteristicvaluechanged', onValue);
    log('INDICATE assinada ('+g.cIndicate.uuid+').','ok');
  }

  if (g.cWrite) log('WRITE disponível ('+g.cWrite.uuid+').','ok');
  else log('Characteristic WRITE não encontrada.','warn');

  startKeepAlive();
}

async function connectFlow(device){
  g.device = device;
  log(`Selecionado: ${device.name||'(sem nome)'} — ID: ${device.id}`);
  g.server = await device.gatt.connect();

  // bateria (opcional)
  g.battery='';
  if (document.getElementById('battery').checked) {
    try{
      const bs=await g.server.getPrimaryService('battery_service');
      const bc=await bs.getCharacteristic('battery_level');
      g.battery=(await bc.readValue()).getUint8(0);
      log(`Bateria: ${g.battery}%`,'ok');
    }catch{ log('Battery service indisponível.','warn'); }
  }

  await readDISLabel();
  await setupServiceAndChars(document.getElementById('svc').value.trim());

  device.addEventListener('gattserverdisconnected', async () => {
    log('Desconectado.','warn');
    clearInterval(g.keepTimer);
    if (document.getElementById('autorec').checked && !g.reconnecting) {
      g.reconnecting = true;
      try{
        log('Tentando reconectar…','muted');
        await device.gatt.connect();
        g.reconnecting = false;
        log('Reconectado.','ok');
        await setupServiceAndChars(document.getElementById('svc').value.trim());
      } catch {
        g.reconnecting = false;
        log('Falha ao reconectar. Toque em “Conectar & Assinar”.','warn');
      }
    }
  });
}

async function connectAndSubscribe(){
  try{
    const SVC=document.getElementById('svc').value.trim();
    if(!navigator.bluetooth){ log('Web Bluetooth não suportado (use Chrome no Android).','err'); return; }

    const REQS=[
      { filters:[{namePrefix:'SY'}], optionalServices:[SVC,'battery_service','device_information'] },
      { acceptAllDevices:true, optionalServices:[SVC,'battery_service','device_information'] }
    ];

    let device=null;
    for(const opt of REQS){
      try{ log('Procurando dispositivo BLE…'); device=await navigator.bluetooth.requestDevice(opt); if(device) break; }
      catch{ log('Tentativa de descoberta falhou; tentando outra…','warn'); }
    }
    if(!device) throw new Error('Não foi possível selecionar o dispositivo.');

    await connectFlow(device);
  }catch(e){
    log('Erro: '+e,'err');
  }
}

function disconnectNow(){
  try{
    document.getElementById('autorec').checked = false; // evita reconectar
    clearInterval(g.keepTimer);
    if(g?.device?.gatt?.connected){ g.device.gatt.disconnect(); }
    g = { device:null, server:null, svc:null, cNotify:null, cIndicate:null, cWrite:null, battery:'', deviceLabel:'', keepTimer:null, reconnecting:false };
    log('Conexão encerrada.','warn');
  }catch(e){ log('Falha ao desconectar: '+e,'err'); }
}

async function writeCmd(bytes){
  if(!g.cWrite){ log('WRITE não disponível.','err'); return; }
  try{
    await g.cWrite.writeValueWithoutResponse(new Uint8Array(bytes));
    log('Comando enviado: '+bytes.map(b=>'0x'+b.toString(16).padStart(2,'0')).join(' '));
  }catch(e){ log('Falha ao enviar comando: '+e,'err'); }
}

// UI
document.getElementById('btnConnect').addEventListener('click', connectAndSubscribe);
document.getElementById('btnDisconnect').addEventListener('click', disconnectNow);
document.getElementById('btnReq01').addEventListener('click', ()=>writeCmd([0x01]));
document.getElementById('btnReqR').addEventListener('click', ()=>writeCmd([0x72]));  // 'r'
document.getElementById('btnStart').addEventListener('click', ()=>writeCmd([0x02]));
document.getElementById('btnStop').addEventListener('click', ()=>writeCmd([0x03]));
</script>
</body>
</html>
